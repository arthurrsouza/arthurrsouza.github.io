"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkember_enterprise"] = self["webpackChunkember_enterprise"] || []).push([["vendors-node_modules_pnpm_glimmer_component_2_0_0_node_modules_glimmer_component_dist_index_js"],{

/***/ "../node_modules/.pnpm/@glimmer+component@2.0.0/node_modules/@glimmer/component/dist/index.js":
/*!****************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@glimmer+component@2.0.0/node_modules/@glimmer/component/dist/index.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ GlimmerComponent)\n/* harmony export */ });\n/* harmony import */ var _glimmer_env__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @glimmer/env */ \"../node_modules/.pnpm/@glimmer+env@0.1.7/node_modules/@glimmer/env/dist/modules/es2017/index.js\");\n/* harmony import */ var _ember_component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ember/component */ \"../node_modules/.pnpm/ember-source@5.12.0_@glimmer+component@2.0.0_@glint+template@1.5.0_rsvp@4.8.5_webpack@5.98.0_webpack-cli@6.0.1_/node_modules/ember-source/dist/packages/@ember/component/index.js\");\n/* harmony import */ var _ember_destroyable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ember/destroyable */ \"../node_modules/.pnpm/ember-source@5.12.0_@glimmer+component@2.0.0_@glint+template@1.5.0_rsvp@4.8.5_webpack@5.98.0_webpack-cli@6.0.1_/node_modules/ember-source/dist/packages/@ember/destroyable/index.js\");\n/* harmony import */ var _ember_runloop__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ember/runloop */ \"../node_modules/.pnpm/ember-source@5.12.0_@glimmer+component@2.0.0_@glint+template@1.5.0_rsvp@4.8.5_webpack@5.98.0_webpack-cli@6.0.1_/node_modules/ember-source/dist/packages/@ember/runloop/index.js\");\n/* harmony import */ var _ember_owner__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ember/owner */ \"../node_modules/.pnpm/ember-source@5.12.0_@glimmer+component@2.0.0_@glint+template@1.5.0_rsvp@4.8.5_webpack@5.98.0_webpack-cli@6.0.1_/node_modules/ember-source/dist/packages/@ember/owner/index.js\");\n\n\n\n\n\n\nconst DESTROYING = new WeakMap();\nconst DESTROYED = new WeakMap();\nfunction setDestroying(component) {\n  DESTROYING.set(component, true);\n}\nfunction setDestroyed(component) {\n  DESTROYED.set(component, true);\n}\n\n// This provides a type-safe `WeakMap`: the getter and setter link the key to a\n// specific value. This is how `WeakMap`s actually behave, but the TS type\n// system does not (yet!) have a good way to capture that for types like\n// `WeakMap` where the type is generic over another generic type (here, `Args`).\n\n// SAFETY: this only holds because we *only* acces this when `DEBUG` is `true`.\n// There is not a great way to connect that data in TS at present.\nlet ARGS_SET;\nif (_glimmer_env__WEBPACK_IMPORTED_MODULE_0__.DEBUG) {\n  ARGS_SET = new WeakMap();\n}\n\n// --- Type utilities for component signatures --- //\n// Type-only \"symbol\" to use with `EmptyObject` below, so that it is *not*\n// equivalent to an empty interface.\n\n/**\n * This provides us a way to have a \"fallback\" which represents an empty object,\n * without the downsides of how TS treats `{}`. Specifically: this will\n * correctly leverage \"excess property checking\" so that, given a component\n * which has no named args, if someone invokes it with any named args, they will\n * get a type error.\n *\n * @internal This is exported so declaration emit works (if it were not emitted,\n *   declarations which fall back to it would not work). It is *not* intended for\n *   public usage, and the specific mechanics it uses may change at any time.\n *   The location of this export *is* part of the public API, because moving it\n *   will break existing declarations, but is not legal for end users to import\n *   themselves, so ***DO NOT RELY ON IT***.\n */\n\n/** Given a signature `S`, get back the `Args` type. */\n\n/**\n * Given any allowed shorthand form of a signature, desugars it to its full\n * expanded type.\n *\n * @internal This is only exported so we can avoid duplicating it in\n *   [Glint](https://github.com/typed-ember/glint) or other such tooling. It is\n *   *not* intended for public usage, and the specific mechanics it uses may\n *   change at any time. Although the signature produced by is part of Glimmer's\n *   public API the existence and mechanics of this specific symbol are *not*,\n *   so ***DO NOT RELY ON IT***.\n */\n// The conditional type here is because TS applies conditional types\n// distributively. This means that for union types, checks like `keyof T` get\n// all the keys from all elements of the union, instead of ending up as `never`\n// and then always falling into the `Signature` path instead of falling back to\n// the legacy args handling path.\n\n/**\n * @internal we use this type for convenience internally; inference means users\n *   should not normally need to name it\n */\n\n/**\n * The `Component` class defines an encapsulated UI element that is rendered to\n * the DOM. A component is made up of a template and, optionally, this component\n * object.\n *\n * ## Defining a Component\n *\n * To define a component, subclass `Component` and add your own properties,\n * methods and lifecycle hooks:\n *\n * ```ts\n * import Component from '@glimmer/component';\n *\n * export default class extends Component {\n * }\n * ```\n *\n * ## Lifecycle Hooks\n *\n * Lifecycle hooks allow you to respond to changes to a component, such as when\n * it gets created, rendered, updated or destroyed. To add a lifecycle hook to a\n * component, implement the hook as a method on your component subclass.\n *\n * For example, to be notified when Glimmer has rendered your component so you\n * can attach a legacy jQuery plugin, implement the `didInsertElement()` method:\n *\n * ```ts\n * import Component from '@glimmer/component';\n *\n * export default class extends Component {\n *   didInsertElement() {\n *     $(this.element).pickadate();\n *   }\n * }\n * ```\n *\n * ## Data for Templates\n *\n * `Component`s have two different kinds of data, or state, that can be\n * displayed in templates:\n *\n * 1. Arguments\n * 2. Properties\n *\n * Arguments are data that is passed in to a component from its parent\n * component. For example, if I have a `UserGreeting` component, I can pass it\n * a name and greeting to use:\n *\n * ```hbs\n * <UserGreeting @name=\"Ricardo\" @greeting=\"Olá\" />\n * ```\n *\n * Inside my `UserGreeting` template, I can access the `@name` and `@greeting`\n * arguments that I've been given:\n *\n * ```hbs\n * {{@greeting}}, {{@name}}!\n * ```\n *\n * Arguments are also available inside my component:\n *\n * ```ts\n * console.log(this.args.greeting); // prints \"Olá\"\n * ```\n *\n * Properties, on the other hand, are internal to the component and declared in\n * the class. You can use properties to store data that you want to show in the\n * template, or pass to another component as an argument.\n *\n * ```ts\n * import Component from '@glimmer/component';\n *\n * export default class extends Component {\n *   user = {\n *     name: 'Robbie'\n *   }\n * }\n * ```\n *\n * In the above example, we've defined a component with a `user` property that\n * contains an object with its own `name` property.\n *\n * We can render that property in our template:\n *\n * ```hbs\n * Hello, {{user.name}}!\n * ```\n *\n * We can also take that property and pass it as an argument to the\n * `UserGreeting` component we defined above:\n *\n * ```hbs\n * <UserGreeting @greeting=\"Hello\" @name={{user.name}} />\n * ```\n *\n * ## Arguments vs. Properties\n *\n * Remember, arguments are data that was given to your component by its parent\n * component, and properties are data your component has defined for itself.\n *\n * You can tell the difference between arguments and properties in templates\n * because arguments always start with an `@` sign (think \"A is for arguments\"):\n *\n * ```hbs\n * {{@firstName}}\n * ```\n *\n * We know that `@firstName` came from the parent component, not the current\n * component, because it starts with `@` and is therefore an argument.\n *\n * On the other hand, if we see:\n *\n * ```hbs\n * {{name}}\n * ```\n *\n * We know that `name` is a property on the component. If we want to know where\n * the data is coming from, we can go look at our component class to find out.\n *\n * Inside the component itself, arguments always show up inside the component's\n * `args` property. For example, if `{{@firstName}}` is `Tom` in the template,\n * inside the component `this.args.firstName` would also be `Tom`.\n */\nlet GlimmerComponent$1 = class GlimmerComponent {\n  /**\n   * Constructs a new component and assigns itself the passed properties. You\n   * should not construct new components yourself. Instead, Glimmer will\n   * instantiate new components automatically as it renders.\n   *\n   * @param owner\n   * @param args\n   */\n  constructor(owner, args) {\n    if (_glimmer_env__WEBPACK_IMPORTED_MODULE_0__.DEBUG && !(owner !== null && typeof owner === 'object' && ARGS_SET.has(args))) {\n      throw new Error(`You must pass both the owner and args to super() in your component: ${this.constructor.name}. You can pass them directly, or use ...arguments to pass all arguments through.`);\n    }\n    this.args = args;\n    DESTROYING.set(this, false);\n    DESTROYED.set(this, false);\n  }\n\n  /**\n   * Named arguments passed to the component from its parent component.\n   * They can be accessed in JavaScript via `this.args.argumentName` and in the template via `@argumentName`.\n   *\n   * Say you have the following component, which will have two `args`, `firstName` and `lastName`:\n   *\n   * ```hbs\n   * <my-component @firstName=\"Arthur\" @lastName=\"Dent\" />\n   * ```\n   *\n   * If you needed to calculate `fullName` by combining both of them, you would do:\n   *\n   * ```ts\n   * didInsertElement() {\n   *   console.log(`Hi, my full name is ${this.args.firstName} ${this.args.lastName}`);\n   * }\n   * ```\n   *\n   * While in the template you could do:\n   *\n   * ```hbs\n   * <p>Welcome, {{@firstName}} {{@lastName}}!</p>\n   * ```\n   */\n  args;\n  get isDestroying() {\n    return DESTROYING.get(this) || false;\n  }\n  get isDestroyed() {\n    return DESTROYED.get(this) || false;\n  }\n\n  /**\n   * Called before the component has been removed from the DOM.\n   */\n  willDestroy() {}\n};\n\nclass BaseComponentManager {\n  owner;\n  constructor(owner) {\n    this.owner = owner;\n  }\n  createComponent(ComponentClass, args) {\n    if (_glimmer_env__WEBPACK_IMPORTED_MODULE_0__.DEBUG) {\n      ARGS_SET.set(args.named, true);\n    }\n    return new ComponentClass(this.owner, args.named);\n  }\n  getContext(component) {\n    return component;\n  }\n}\n\nconst CAPABILITIES = (0,_ember_component__WEBPACK_IMPORTED_MODULE_1__.capabilities)('3.13', {\n  destructor: true,\n  asyncLifecycleCallbacks: false,\n  updateHook: false\n});\nfunction scheduledDestroyComponent(component) {\n  if (component.isDestroyed) {\n    return;\n  }\n  (0,_ember_destroyable__WEBPACK_IMPORTED_MODULE_2__.destroy)(component);\n  setDestroyed(component);\n}\n\n/**\n * This component manager runs in Ember.js environments and extends the base component manager to:\n *\n * 1. Properly destroy the component's associated `meta` data structure\n * 2. Schedule destruction using Ember's runloop\n */\nclass EmberGlimmerComponentManager extends BaseComponentManager {\n  capabilities = CAPABILITIES;\n  destroyComponent(component) {\n    if (component.isDestroying) {\n      return;\n    }\n    setDestroying(component);\n    (0,_ember_runloop__WEBPACK_IMPORTED_MODULE_3__.schedule)('actions', component, component.willDestroy);\n    (0,_ember_runloop__WEBPACK_IMPORTED_MODULE_3__.schedule)('destroy', this, scheduledDestroyComponent, component);\n  }\n}\n\n/**\n  A component is a reusable UI element that consists of a `.hbs` template and an\n  optional JavaScript class that defines its behavior. For example, someone\n  might make a `button` in the template and handle the click behavior in the\n  JavaScript file that shares the same name as the template.\n\n  Components are broken down into two categories:\n\n  - Components _without_ JavaScript, that are based only on a template. These\n    are called Template-only or TO components.\n  - Components _with_ JavaScript, which consist of a template and a backing\n    class.\n\n  Ember ships with two types of JavaScript classes for components:\n\n  1. Glimmer components, imported from `@glimmer/component`, which are the\n     default components for Ember Octane (3.15) and more recent editions.\n  2. Classic components, imported from `@ember/component`, which were the\n     default for older editions of Ember (pre 3.15).\n\n  Below is the documentation for Template-only and Glimmer components. If you\n  are looking for the API documentation for Classic components, it is\n  [available here](/ember/release/classes/Component). The source code for\n  Glimmer components can be found in [`@glimmer/component`](https://github.com/glimmerjs/glimmer.js/tree/master/packages/%40glimmer/component).\n\n  ## Defining a Template-only Component\n\n  The simplest way to create a component is to create a template file in\n  `app/templates/components`. For example, if you name a template\n  `app/templates/components/person-profile.hbs`:\n\n  ```app/templates/components/person-profile.hbs\n  <h1>{{@person.name}}</h1>\n  <img src={{@person.avatar}}>\n  <p class='signature'>{{@person.signature}}</p>\n  ```\n\n  You will be able to use `<PersonProfile />` to invoke this component elsewhere\n  in your application:\n\n  ```app/templates/application.hbs\n  <PersonProfile @person={{this.currentUser}} />\n  ```\n\n  Note that component names are capitalized here in order to distinguish them\n  from regular HTML elements, but they are dasherized in the file system.\n\n  While the angle bracket invocation form is generally preferred, it is also\n  possible to invoke the same component with the `{{person-profile}}` syntax:\n\n  ```app/templates/application.hbs\n  {{person-profile person=this.currentUser}}\n  ```\n\n  Note that with this syntax, you use dashes in the component name and\n  arguments are passed without the `@` sign.\n\n  In both cases, Ember will render the content of the component template we\n  created above. The end result will be something like this:\n\n  ```html\n  <h1>Tomster</h1>\n  <img src=\"https://emberjs.com/tomster.jpg\">\n  <p class='signature'>Out of office this week</p>\n  ```\n\n  ## File System Nesting\n\n  Components can be nested inside sub-folders for logical groupping. For\n  example, if we placed our template in\n  `app/templates/components/person/short-profile.hbs`, we can invoke it as\n  `<Person::ShortProfile />`:\n\n  ```app/templates/application.hbs\n  <Person::ShortProfile @person={{this.currentUser}} />\n  ```\n\n  Or equivalently, `{{person/short-profile}}`:\n\n  ```app/templates/application.hbs\n  {{person/short-profile person=this.currentUser}}\n  ```\n\n  ## Using Blocks\n\n  You can use `yield` inside a template to include the **contents** of any block\n  attached to the component. For instance, if we added a `{{yield}}` to our\n  component like so:\n\n  ```app/templates/components/person-profile.hbs\n  <h1>{{@person.name}}</h1>\n  {{yield}}\n  ```\n\n  We could then invoke it like this:\n\n  ```handlebars\n  <PersonProfile @person={{this.currentUser}}>\n    <p>Admin mode</p>\n  </PersonProfile>\n  ```\n\n  or with curly syntax like this:\n\n  ```handlebars\n  {{#person-profile person=this.currentUser}}\n    <p>Admin mode</p>\n  {{/person-profile}}\n  ```\n\n  And the content passed in between the brackets of the component would be\n  rendered in the same place as the `{{yield}}` within it, replacing it.\n\n  Blocks are executed in their original context, meaning they have access to the\n  scope and any in-scope variables where they were defined.\n\n  ### Passing parameters to blocks\n\n  You can also pass positional parameters to `{{yield}}`, which are then made\n  available in the block:\n\n  ```app/templates/components/person-profile.hbs\n  <h1>{{@person.name}}</h1>\n  {{yield @person.signature}}\n  ```\n\n  We can then use this value in the block like so:\n\n  ```handlebars\n  <PersonProfile @person={{this.currentUser}} as |signature|>\n    {{signature}}\n  </PersonProfile>\n  ```\n\n  ### Passing multiple blocks\n\n  You can pass multiple blocks to a component by giving them names, and\n  specifying which block you are yielding to with `{{yield}}`. For instance, if\n  we wanted to add a way for users to customize the title of our\n  `<PersonProfile>` component, we could add a named block inside of the header:\n\n  ```app/templates/components/person-profile.hbs\n  <h1>{{yield to=\"title\"}}</h1>\n  {{yield}}\n  ```\n\n  This component could then be invoked like so:\n\n  ```handlebars\n  <PersonProfile @person={{this.currentUser}}>\n    <:title>{{this.currentUser.name}}</:title>\n    <:default>{{this.currentUser.signature}}</:default>\n  </PersonProfile>\n  ```\n\n  When passing named blocks, you must name every block, including the `default`\n  block, which is the block that is defined if you do not pass a `to` parameter\n  to `{{yield}}`. Whenever you invoke a component without passing explicitly\n  named blocks, the passed block is considered the `default` block.\n\n  ### Passing parameters to named blocks\n\n  You can also pass parameters to named blocks:\n\n  ```app/templates/components/person-profile.hbs\n  <h1>{{yield @person.name to=\"title\"}}</h1>\n  {{yield @person.signature}}\n  ```\n\n  These parameters can then be used like so:\n\n  ```handlebars\n  <PersonProfile @person={{this.currentUser}}>\n    <:title as |name|>{{name}}</:title>\n    <:default as |signature|>{{signature}}</:default>\n  </PersonProfile>\n  ```\n\n  ### Checking to see if a block exists\n\n  You can also check to see if a block exists using the `(has-block)` keyword,\n  and conditionally use it, or provide a default template instead.\n\n  ```app/templates/components/person-profile.hbs\n  <h1>\n    {{#if (has-block \"title\")}}\n      {{yield @person.name to=\"title\"}}\n    {{else}}\n      {{@person.name}}\n    {{/if}}\n  </h1>\n\n  {{#if (has-block)}}\n    {{yield @person.signature}}\n  {{else}}\n    {{@person.signature}}\n  {{/if}}\n  ```\n\n  With this template, we can then optionally pass in one block, both blocks, or\n  none at all:\n\n  ```handlebars\n  {{! passing both blocks }}\n  <PersonProfile @person={{this.currentUser}}>\n    <:title as |name|>{{name}}</:title>\n    <:default as |signature|>{{signature}}</:default>\n  </PersonProfile>\n\n  {{! passing just the title block }}\n  <PersonProfile @person={{this.currentUser}}>\n    <:title as |name|>{{name}}</:title>\n  </PersonProfile>\n\n  {{! passing just the default block }}\n  <PersonProfile @person={{this.currentUser}} as |signature|>\n    {{signature}}\n  </PersonProfile>\n\n  {{! not passing any blocks }}\n  <PersonProfile @person={{this.currentUser}}/>\n  ```\n\n  ### Checking to see if a block has parameters\n\n  We can also check if a block receives parameters using the `(has-block-params)`\n  keyword, and conditionally yield different values if so.\n\n  ```app/templates/components/person-profile.hbs\n  {{#if (has-block-params)}}\n    {{yield @person.signature}}\n  {{else}}\n    {{yield}}\n  {{/if}}\n  ```\n\n  ## Customizing Components With JavaScript\n\n  To add JavaScript to a component, create a JavaScript file in the same\n  location as the template file, with the same name, and export a subclass\n  of `Component` as the default value. For example, to add Javascript to the\n  `PersonProfile` component which we defined above, we would create\n  `app/components/person-profile.js` and export our class as the default, like\n  so:\n\n  ```app/components/person-profile.js\n  import Component from '@glimmer/component';\n\n  export default class PersonProfileComponent extends Component {\n    get displayName() {\n      let { title, firstName, lastName } = this.args.person;\n\n      if (title) {\n        return `${title} ${lastName}`;\n      } else {\n        return `${firstName} ${lastName}`;\n      }\n    })\n  }\n  ```\n\n  You can add your own properties, methods, and lifecycle hooks to this\n  subclass to customize its behavior, and you can reference the instance of the\n  class in your template using `{{this}}`. For instance, we could access the\n  `displayName` property of our `PersonProfile` component instance in the\n  template like this:\n\n  ```app/templates/components/person-profile.hbs\n  <h1>{{this.displayName}}</h1>\n  {{yield}}\n  ```\n\n  ## `constructor`\n\n  params: `owner` object and `args` object\n\n  Constructs a new component and assigns itself the passed properties. The\n  constructor is run whenever a new instance of the component is created, and\n  can be used to setup the initial state of the component.\n\n  ```javascript\n  import Component from '@glimmer/component';\n\n  export default class SomeComponent extends Component {\n    constructor(owner, args) {\n      super(owner, args);\n\n      if (this.args.displayMode === 'list') {\n        this.items = [];\n      }\n    }\n  }\n  ```\n\n  Service injections and arguments are available in the constructor.\n\n  ```javascript\n  import Component from '@glimmer/component';\n  import { service } from '@ember/service';\n\n  export default class SomeComponent extends Component {\n    @service myAnimations;\n\n    constructor(owner, args) {\n      super(owner, args);\n\n      if (this.args.fadeIn === true) {\n        this.myAnimations.register(this, 'fade-in');\n      }\n    }\n  }\n  ```\n\n  ## `willDestroy`\n\n  `willDestroy` is called after the component has been removed from the DOM, but\n  before the component is fully destroyed. This lifecycle hook can be used to\n  cleanup the component and any related state.\n\n  ```javascript\n  import Component from '@glimmer/component';\n  import { service } from '@ember/service';\n\n  export default class SomeComponent extends Component {\n    @service myAnimations;\n\n    willDestroy() {\n      super.willDestroy(...arguments);\n\n      this.myAnimations.unregister(this);\n    }\n  }\n  ```\n\n  ## `args`\n\n  The `args` property of Glimmer components is an object that contains the\n  _arguments_ that are passed to the component. For instance, the\n  following component usage:\n\n  ```handlebars\n  <SomeComponent @fadeIn={{true}} />\n  ```\n\n  Would result in the following `args` object to be passed to the component:\n\n  ```javascript\n  { fadeIn: true }\n  ```\n\n  `args` can be accessed at any point in the component lifecycle, including\n  `constructor` and `willDestroy`. They are also automatically marked as tracked\n  properties, and they can be depended on as computed property dependencies:\n\n  ```javascript\n  import Component from '@glimmer/component';\n  import { computed } from '@ember/object';\n\n  export default class SomeComponent extends Component {\n\n    @computed('args.someValue')\n    get computedGetter() {\n      // updates whenever args.someValue updates\n      return this.args.someValue;\n    }\n\n    get standardGetter() {\n      // updates whenever args.anotherValue updates (Ember 3.13+)\n      return this.args.anotherValue;\n    }\n  }\n  ```\n\n  ## `isDestroying`\n\n  A boolean flag to tell if the component is in the process of destroying. This is set to\n  true before `willDestroy` is called.\n\n  ## `isDestroyed`\n  A boolean to tell if the component has been fully destroyed. This is set to true\n  after `willDestroy` is called.\n\n  @module @glimmer/component\n  @public\n*/\nclass GlimmerComponent extends GlimmerComponent$1 {\n  constructor(owner, args) {\n    super(owner, args);\n    if (_glimmer_env__WEBPACK_IMPORTED_MODULE_0__.DEBUG && !(owner !== null && typeof owner === 'object')) {\n      throw new Error(`You must pass both the owner and args to super() in your component: ${this.constructor.name}. You can pass them directly, or use ...arguments to pass all arguments through.`);\n    }\n    (0,_ember_owner__WEBPACK_IMPORTED_MODULE_4__.setOwner)(this, owner);\n  }\n}\n(0,_ember_component__WEBPACK_IMPORTED_MODULE_1__.setComponentManager)(owner => {\n  return new EmberGlimmerComponentManager(owner);\n}, GlimmerComponent);\n\n\n\n\n//# sourceURL=webpack://ember-enterprise/../node_modules/.pnpm/@glimmer+component@2.0.0/node_modules/@glimmer/component/dist/index.js?");

/***/ }),

/***/ "../node_modules/.pnpm/@glimmer+env@0.1.7/node_modules/@glimmer/env/dist/modules/es2017/index.js":
/*!*******************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@glimmer+env@0.1.7/node_modules/@glimmer/env/dist/modules/es2017/index.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CI: () => (/* binding */ CI),\n/* harmony export */   DEBUG: () => (/* binding */ DEBUG)\n/* harmony export */ });\nconst DEBUG = false;\nconst CI = false;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJzcmMvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsTUFBTSxDQUFDLE1BQU0sS0FBSyxHQUFHLEtBQUssQ0FBQztBQUMzQixNQUFNLENBQUMsTUFBTSxFQUFFLEdBQUcsS0FBSyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IERFQlVHID0gZmFsc2U7XG5leHBvcnQgY29uc3QgQ0kgPSBmYWxzZTtcbiJdfQ==\n\n//# sourceURL=webpack://ember-enterprise/../node_modules/.pnpm/@glimmer+env@0.1.7/node_modules/@glimmer/env/dist/modules/es2017/index.js?");

/***/ }),

/***/ "../node_modules/.pnpm/ember-source@5.12.0_@glimmer+component@2.0.0_@glint+template@1.5.0_rsvp@4.8.5_webpack@5.98.0_webpack-cli@6.0.1_/node_modules/ember-source/dist/packages/@ember/destroyable/index.js":
/*!*****************************************************************************************************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/ember-source@5.12.0_@glimmer+component@2.0.0_@glint+template@1.5.0_rsvp@4.8.5_webpack@5.98.0_webpack-cli@6.0.1_/node_modules/ember-source/dist/packages/@ember/destroyable/index.js ***!
  \*****************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assertDestroyablesDestroyed: () => (/* reexport safe */ _glimmer_destroyable_index_js__WEBPACK_IMPORTED_MODULE_0__.assertDestroyablesDestroyed),\n/* harmony export */   associateDestroyableChild: () => (/* reexport safe */ _glimmer_destroyable_index_js__WEBPACK_IMPORTED_MODULE_0__.associateDestroyableChild),\n/* harmony export */   destroy: () => (/* reexport safe */ _glimmer_destroyable_index_js__WEBPACK_IMPORTED_MODULE_0__.destroy),\n/* harmony export */   enableDestroyableTracking: () => (/* reexport safe */ _glimmer_destroyable_index_js__WEBPACK_IMPORTED_MODULE_0__.enableDestroyableTracking),\n/* harmony export */   isDestroyed: () => (/* reexport safe */ _glimmer_destroyable_index_js__WEBPACK_IMPORTED_MODULE_0__.isDestroyed),\n/* harmony export */   isDestroying: () => (/* reexport safe */ _glimmer_destroyable_index_js__WEBPACK_IMPORTED_MODULE_0__.isDestroying),\n/* harmony export */   registerDestructor: () => (/* binding */ registerDestructor),\n/* harmony export */   unregisterDestructor: () => (/* binding */ unregisterDestructor)\n/* harmony export */ });\n/* harmony import */ var _glimmer_destroyable_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../@glimmer/destroyable/index.js */ \"../node_modules/.pnpm/ember-source@5.12.0_@glimmer+component@2.0.0_@glint+template@1.5.0_rsvp@4.8.5_webpack@5.98.0_webpack-cli@6.0.1_/node_modules/ember-source/dist/packages/@glimmer/destroyable/index.js\");\n\n\n\n/**\n  Ember manages the lifecycles and lifetimes of many built in constructs, such\n  as components, and does so in a hierarchical way - when a parent component is\n  destroyed, all of its children are destroyed as well.\n\n  This destroyables API exposes the basic building blocks for destruction:\n\n  * registering a function to be ran when an object is destroyed\n  * checking if an object is in a destroying state\n  * associate an object as a child of another so that the child object will be destroyed\n    when the associated parent object is destroyed.\n\n  @module @ember/destroyable\n  @public\n*/\n\n/**\n  This function is used to associate a destroyable object with a parent. When the parent\n  is destroyed, all registered children will also be destroyed.\n\n  ```js\n  class CustomSelect extends Component {\n    constructor(...args) {\n      super(...args);\n\n      // obj is now a child of the component. When the component is destroyed,\n      // obj will also be destroyed, and have all of its destructors triggered.\n      this.obj = associateDestroyableChild(this, {});\n    }\n  }\n  ```\n\n  Returns the associated child for convenience.\n\n  @method associateDestroyableChild\n  @for @ember/destroyable\n  @param {Object|Function} parent the destroyable to entangle the child destroyables lifetime with\n  @param {Object|Function} child the destroyable to be entangled with the parents lifetime\n  @returns {Object|Function} the child argument\n  @static\n  @public\n*/\n\n/**\n Receives a destroyable, and returns true if the destroyable has begun destroying. Otherwise returns\n false.\n\n  ```js\n  let obj = {};\n  isDestroying(obj); // false\n  destroy(obj);\n  isDestroying(obj); // true\n  // ...sometime later, after scheduled destruction\n  isDestroyed(obj); // true\n  isDestroying(obj); // true\n  ```\n\n  @method isDestroying\n  @for @ember/destroyable\n  @param {Object|Function} destroyable the object to check\n  @returns {Boolean}\n  @static\n  @public\n*/\n\n/**\n  Receives a destroyable, and returns true if the destroyable has finished destroying. Otherwise\n  returns false.\n\n  ```js\n  let obj = {};\n\n  isDestroyed(obj); // false\n  destroy(obj);\n\n  // ...sometime later, after scheduled destruction\n\n  isDestroyed(obj); // true\n  ```\n\n  @method isDestroyed\n  @for @ember/destroyable\n  @param {Object|Function} destroyable the object to check\n  @returns {Boolean}\n  @static\n  @public\n*/\n\n/**\n  Initiates the destruction of a destroyable object. It runs all associated destructors, and then\n  destroys all children recursively.\n\n  ```js\n  let obj = {};\n\n  registerDestructor(obj, () => console.log('destroyed!'));\n\n  destroy(obj); // this will schedule the destructor to be called\n\n  // ...some time later, during scheduled destruction\n\n  // destroyed!\n  ```\n\n  Destruction via `destroy()` follows these steps:\n\n  1, Mark the destroyable such that `isDestroying(destroyable)` returns `true`\n  2, Call `destroy()` on each of the destroyable's associated children\n  3, Schedule calling the destroyable's destructors\n  4, Schedule setting destroyable such that `isDestroyed(destroyable)` returns `true`\n\n  This results in the entire tree of destroyables being first marked as destroying,\n  then having all of their destructors called, and finally all being marked as isDestroyed.\n  There won't be any in between states where some items are marked as `isDestroying` while\n  destroying, while others are not.\n\n  @method destroy\n  @for @ember/destroyable\n  @param {Object|Function} destroyable the object to destroy\n  @static\n  @public\n*/\n\n/**\n  This function asserts that all objects which have associated destructors or associated children\n  have been destroyed at the time it is called. It is meant to be a low level hook that testing\n  frameworks can use to hook into and validate that all destroyables have in fact been destroyed.\n\n  This function requires that `enableDestroyableTracking` was called previously, and is only\n  available in non-production builds.\n\n  @method assertDestroyablesDestroyed\n  @for @ember/destroyable\n  @static\n  @public\n*/\n\n/**\n  This function instructs the destroyable system to keep track of all destroyables (their\n  children, destructors, etc). This enables a future usage of `assertDestroyablesDestroyed`\n  to be used to ensure that all destroyable tasks (registered destructors and associated children)\n  have completed when `assertDestroyablesDestroyed` is called.\n\n  @method enableDestroyableTracking\n  @for @ember/destroyable\n  @static\n  @public\n*/\n\n/**\n  Receives a destroyable object and a destructor function, and associates the\n  function with it. When the destroyable is destroyed with destroy, or when its\n  parent is destroyed, the destructor function will be called.\n\n  ```js\n  import Component from '@glimmer/component';\n  import { registerDestructor } from '@ember/destroyable';\n\n  class Modal extends Component {\n    @service resize;\n\n    constructor(...args) {\n      super(...args);\n\n      this.resize.register(this, this.layout);\n\n      registerDestructor(this, () => this.resize.unregister(this));\n    }\n  }\n  ```\n\n  Multiple destructors can be associated with a given destroyable, and they can be\n  associated over time, allowing libraries to dynamically add destructors as needed.\n  `registerDestructor` also returns the associated destructor function, for convenience.\n\n  The destructor function is passed a single argument, which is the destroyable itself.\n  This allows the function to be reused multiple times for many destroyables, rather\n  than creating a closure function per destroyable.\n\n  ```js\n  import Component from '@glimmer/component';\n  import { registerDestructor } from '@ember/destroyable';\n\n  function unregisterResize(instance) {\n    instance.resize.unregister(instance);\n  }\n\n  class Modal extends Component {\n    @service resize;\n\n    constructor(...args) {\n      super(...args);\n\n      this.resize.register(this, this.layout);\n\n      registerDestructor(this, unregisterResize);\n    }\n  }\n  ```\n\n  @method registerDestructor\n  @for @ember/destroyable\n  @param {Object|Function} destroyable the destroyable to register the destructor function with\n  @param {Function} destructor the destructor to run when the destroyable object is destroyed\n  @static\n  @public\n*/\nfunction registerDestructor(destroyable, destructor) {\n  return (0,_glimmer_destroyable_index_js__WEBPACK_IMPORTED_MODULE_0__.registerDestructor)(destroyable, destructor);\n}\n\n/**\n  Receives a destroyable and a destructor function, and de-associates the destructor\n  from the destroyable.\n\n  ```js\n  import Component from '@glimmer/component';\n  import { registerDestructor, unregisterDestructor } from '@ember/destroyable';\n\n  class Modal extends Component {\n    @service modals;\n\n    constructor(...args) {\n      super(...args);\n\n      this.modals.add(this);\n\n      this.modalDestructor = registerDestructor(this, () => this.modals.remove(this));\n    }\n\n    @action pinModal() {\n      unregisterDestructor(this, this.modalDestructor);\n    }\n  }\n  ```\n\n  @method unregisterDestructor\n  @for @ember/destroyable\n  @param {Object|Function} destroyable the destroyable to unregister the destructor function from\n  @param {Function} destructor the destructor to remove from the destroyable\n  @static\n  @public\n*/\nfunction unregisterDestructor(destroyable, destructor) {\n  return (0,_glimmer_destroyable_index_js__WEBPACK_IMPORTED_MODULE_0__.unregisterDestructor)(destroyable, destructor);\n}\n\n\n\n\n//# sourceURL=webpack://ember-enterprise/../node_modules/.pnpm/ember-source@5.12.0_@glimmer+component@2.0.0_@glint+template@1.5.0_rsvp@4.8.5_webpack@5.98.0_webpack-cli@6.0.1_/node_modules/ember-source/dist/packages/@ember/destroyable/index.js?");

/***/ })

}]);