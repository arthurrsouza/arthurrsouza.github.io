{"version":3,"file":"index-Dztb0qgL.js","sources":["../../../../../node_modules/.pnpm/decorator-transforms@2.3.0_@babel+core@7.26.10/node_modules/decorator-transforms/dist/index.js","../../../../../node_modules/.pnpm/decorator-transforms@2.3.0_@babel+core@7.26.10/node_modules/decorator-transforms/dist/global-id-BrhFC90G.js"],"sourcesContent":["import { g as globalId } from \"./global-id-BrhFC90G.js\";\nvar src = {};\nObject.defineProperty(src, \"__esModule\", { value: true });\nvar ImportUtil_1 = src.ImportUtil = void 0;\nclass ImportUtil {\n  constructor(babel, program) {\n    this.babel = babel;\n    this.program = program;\n    this.t = babel.types;\n  }\n  // remove one imported binding. If this is the last thing imported from the\n  // given moduleSpecifier, the whole statement will also be removed.\n  removeImport(moduleSpecifier, exportedName) {\n    for (let topLevelPath of this.program.get(\"body\")) {\n      if (!matchModule(topLevelPath, moduleSpecifier)) {\n        continue;\n      }\n      let importSpecifierPath = topLevelPath.get(\"specifiers\").find((specifierPath) => matchSpecifier(specifierPath, exportedName));\n      if (importSpecifierPath) {\n        if (topLevelPath.node.specifiers.length === 1) {\n          topLevelPath.remove();\n        } else {\n          importSpecifierPath.remove();\n        }\n      }\n    }\n  }\n  // remove all imports from the given moduleSpecifier\n  removeAllImports(moduleSpecifier) {\n    for (let topLevelPath of this.program.get(\"body\")) {\n      if (matchModule(topLevelPath, moduleSpecifier)) {\n        topLevelPath.remove();\n      }\n    }\n  }\n  // Import the given value (if needed) and return an Identifier representing\n  // it.\n  //\n  // This method is trickier to use safely than our higher-level methods\n  // (`insertAfter`, `insertBefore`, `replaceWith`, `mutate`) because after you\n  // insert the identifier into the AST, it's up to you to ensure that babel's\n  // scope system is aware of the new reference. The other methods do that for\n  // you automatically.\n  import(target, moduleSpecifier, exportedName, nameHint) {\n    return this.unreferencedImport(target, moduleSpecifier, exportedName, desiredName(nameHint, exportedName, defaultNameHint(target)));\n  }\n  // Import the given value (if needed) and return an Identifier representing\n  // it.\n  unreferencedImport(target, moduleSpecifier, exportedName, preferredName) {\n    var _a;\n    let isNamespaceImport = exportedName === \"*\";\n    let isDefaultImport = exportedName === \"default\";\n    let isNamedImport = !isDefaultImport && !isNamespaceImport;\n    let declaration = this.findImportFrom(moduleSpecifier);\n    let hasNamespaceSpecifier = declaration === null || declaration === void 0 ? void 0 : declaration.node.specifiers.find((s) => s.type === \"ImportNamespaceSpecifier\");\n    let hasNamedSpecifiers = declaration === null || declaration === void 0 ? void 0 : declaration.node.specifiers.find((s) => s.type === \"ImportSpecifier\");\n    let cannotUseExistingDeclaration = hasNamedSpecifiers && isNamespaceImport || hasNamespaceSpecifier && isNamedImport || hasNamespaceSpecifier && isNamespaceImport;\n    if (!cannotUseExistingDeclaration && declaration) {\n      let specifier = declaration.get(\"specifiers\").find((spec) => matchSpecifier(spec, exportedName));\n      if (specifier && ((_a = target.scope.getBinding(specifier.node.local.name)) === null || _a === void 0 ? void 0 : _a.kind) === \"module\") {\n        return this.t.identifier(specifier.node.local.name);\n      } else {\n        return this.addSpecifier(target, declaration, exportedName, preferredName);\n      }\n    } else {\n      let declaration2 = this.insertAfterExistingImports(this.t.importDeclaration([], this.t.stringLiteral(moduleSpecifier)));\n      return this.addSpecifier(target, declaration2, exportedName, preferredName);\n    }\n  }\n  importForSideEffect(moduleSpecifier) {\n    let declaration = this.findImportFrom(moduleSpecifier);\n    if (!declaration) {\n      this.insertAfterExistingImports(this.t.importDeclaration([], this.t.stringLiteral(moduleSpecifier)));\n    }\n  }\n  replaceWith(target, fn) {\n    return this.mutate((i) => {\n      target.replaceWith(fn(i));\n      return target;\n    }, defaultNameHint(target));\n  }\n  insertAfter(target, fn) {\n    return this.mutate((i) => target.insertAfter(fn(i))[0], defaultNameHint(target));\n  }\n  insertBefore(target, fn) {\n    return this.mutate((i) => target.insertBefore(fn(i))[0], defaultNameHint(target));\n  }\n  // Low-level method for when you don't want to use our higher-level methods\n  // (replaceWith, insertBefore, insertAfter)\n  mutate(fn, defaultNameHint2) {\n    let symbols = /* @__PURE__ */ new Map();\n    const importer = {\n      import: (moduleSpecifier, exportedName, nameHint) => {\n        let identifier = this.t.identifier(\"__babel_import_util_placeholder__\");\n        symbols.set(identifier, { moduleSpecifier, exportedName, nameHint });\n        return identifier;\n      }\n    };\n    const updateReference = (path) => {\n      if (!path.isIdentifier()) {\n        return;\n      }\n      let hit = symbols.get(path.node);\n      if (hit) {\n        let newIdentifier = this.unreferencedImport(path, hit.moduleSpecifier, hit.exportedName, desiredName(hit.nameHint, hit.exportedName, defaultNameHint2));\n        path.replaceWith(newIdentifier);\n        let binding = path.scope.getBinding(newIdentifier.name);\n        if (!binding) {\n          throw new Error(`bug: this is supposed to never happen`);\n        }\n        binding.reference(path);\n      }\n    };\n    let result = fn(importer);\n    updateReference(result);\n    this.babel.traverse(result.node, {\n      ReferencedIdentifier: (path) => {\n        updateReference(path);\n      }\n    }, result.scope, {}, result);\n    return result;\n  }\n  addSpecifier(target, declaration, exportedName, preferredName) {\n    let local = this.t.identifier(unusedNameLike(target, preferredName));\n    let specifier = this.buildSpecifier(exportedName, local);\n    let added;\n    if (specifier.type === \"ImportDefaultSpecifier\") {\n      declaration.node.specifiers.unshift(specifier);\n      added = declaration.get(`specifiers.0`);\n    } else {\n      declaration.node.specifiers.push(specifier);\n      added = declaration.get(`specifiers.${declaration.node.specifiers.length - 1}`);\n    }\n    declaration.scope.registerBinding(\"module\", added);\n    return local;\n  }\n  buildSpecifier(exportedName, localName) {\n    switch (exportedName) {\n      case \"default\":\n        return this.t.importDefaultSpecifier(localName);\n      case \"*\":\n        return this.t.importNamespaceSpecifier(localName);\n      default:\n        return this.t.importSpecifier(localName, this.t.identifier(exportedName));\n    }\n  }\n  findImportFrom(moduleSpecifier) {\n    for (let path of this.program.get(\"body\")) {\n      if (path.isImportDeclaration() && path.node.source.value === moduleSpecifier && path.node.importKind !== \"type\") {\n        return path;\n      }\n    }\n    return void 0;\n  }\n  insertAfterExistingImports(statement) {\n    let lastIndex;\n    for (let [index, node] of this.program.node.body.entries()) {\n      if (node.type === \"ImportDeclaration\") {\n        lastIndex = index;\n      }\n    }\n    if (lastIndex == null) {\n      this.program.node.body.unshift(statement);\n      return this.program.get(\"body.0\");\n    } else {\n      this.program.node.body.splice(lastIndex + 1, 0, statement);\n      return this.program.get(`body.${lastIndex + 1}`);\n    }\n  }\n}\nImportUtil_1 = src.ImportUtil = ImportUtil;\nfunction unusedNameLike(path, name2) {\n  let candidate = name2;\n  let counter = 0;\n  while (path.scope.hasBinding(candidate)) {\n    candidate = `${name2}${counter++}`;\n  }\n  return candidate;\n}\nfunction name(node) {\n  if (node.type === \"StringLiteral\") {\n    return node.value;\n  } else {\n    return node.name;\n  }\n}\nfunction desiredName(nameHint, exportedName, defaultNameHint2) {\n  if (nameHint) {\n    let cleaned = nameHint.replace(/[^a-zA-Z_]([a-z])/g, (_m, letter) => letter.toUpperCase());\n    cleaned = cleaned.replace(/[^a-zA-Z_]/g, \"\");\n    return cleaned;\n  }\n  if (exportedName === \"default\" || exportedName === \"*\") {\n    return defaultNameHint2 !== null && defaultNameHint2 !== void 0 ? defaultNameHint2 : \"a\";\n  } else {\n    return exportedName;\n  }\n}\nfunction defaultNameHint(target) {\n  if (target === null || target === void 0 ? void 0 : target.isIdentifier()) {\n    return target.node.name;\n  } else if (target) {\n    return target.scope.generateUidIdentifierBasedOnNode(target.node).name;\n  } else {\n    return void 0;\n  }\n}\nfunction matchSpecifier(spec, exportedName) {\n  switch (exportedName) {\n    case \"default\":\n      return spec.isImportDefaultSpecifier();\n    case \"*\":\n      return spec.isImportNamespaceSpecifier();\n    default:\n      return spec.isImportSpecifier() && name(spec.node.imported) === exportedName;\n  }\n}\nfunction matchModule(path, moduleSpecifier) {\n  return path.isImportDeclaration() && path.get(\"source\").node.value === moduleSpecifier;\n}\nvar lib$1 = {};\nvar lib = {};\nObject.defineProperty(lib, \"__esModule\", {\n  value: true\n});\nlib.declare = declare;\nlib.declarePreset = void 0;\nconst apiPolyfills = {\n  assertVersion: (api) => (range) => {\n    throwVersionError(range, api.version);\n  }\n};\n{\n  Object.assign(apiPolyfills, {\n    targets: () => () => {\n      return {};\n    },\n    assumption: () => () => {\n      return void 0;\n    }\n  });\n}\nfunction declare(builder) {\n  return (api, options, dirname) => {\n    var _clonedApi2;\n    let clonedApi;\n    for (const name2 of Object.keys(apiPolyfills)) {\n      var _clonedApi;\n      if (api[name2]) continue;\n      (_clonedApi = clonedApi) != null ? _clonedApi : clonedApi = copyApiObject(api);\n      clonedApi[name2] = apiPolyfills[name2](clonedApi);\n    }\n    return builder((_clonedApi2 = clonedApi) != null ? _clonedApi2 : api, options || {}, dirname);\n  };\n}\nconst declarePreset = declare;\nlib.declarePreset = declarePreset;\nfunction copyApiObject(api) {\n  let proto = null;\n  if (typeof api.version === \"string\" && /^7\\./.test(api.version)) {\n    proto = Object.getPrototypeOf(api);\n    if (proto && (!has(proto, \"version\") || !has(proto, \"transform\") || !has(proto, \"template\") || !has(proto, \"types\"))) {\n      proto = null;\n    }\n  }\n  return Object.assign({}, proto, api);\n}\nfunction has(obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\nfunction throwVersionError(range, version) {\n  if (typeof range === \"number\") {\n    if (!Number.isInteger(range)) {\n      throw new Error(\"Expected string or integer value.\");\n    }\n    range = `^${range}.0.0-0`;\n  }\n  if (typeof range !== \"string\") {\n    throw new Error(\"Expected string or integer value.\");\n  }\n  const limit = Error.stackTraceLimit;\n  if (typeof limit === \"number\" && limit < 25) {\n    Error.stackTraceLimit = 25;\n  }\n  let err;\n  if (version.slice(0, 2) === \"7.\") {\n    err = new Error(`Requires Babel \"^7.0.0-beta.41\", but was loaded with \"${version}\". You'll need to update your @babel/core version.`);\n  } else {\n    err = new Error(`Requires Babel \"${range}\", but was loaded with \"${version}\". If you are sure you have a compatible version of @babel/core, it is likely that something in your build process is loading the wrong version. Inspect the stack trace of this error to look for the first entry that doesn't mention \"@babel/core\" or \"babel-core\" to see what is calling Babel.`);\n  }\n  if (typeof limit === \"number\") {\n    Error.stackTraceLimit = limit;\n  }\n  throw Object.assign(err, {\n    code: \"BABEL_VERSION_UNSUPPORTED\",\n    version,\n    range\n  });\n}\nObject.defineProperty(lib$1, \"__esModule\", {\n  value: true\n});\nvar default_1 = lib$1.default = void 0;\nvar _helperPluginUtils = lib;\ndefault_1 = lib$1.default = (0, _helperPluginUtils.declare)((api, options) => {\n  api.assertVersion(7);\n  let {\n    version\n  } = options;\n  {\n    const {\n      legacy\n    } = options;\n    if (legacy !== void 0) {\n      if (typeof legacy !== \"boolean\") {\n        throw new Error(\".legacy must be a boolean.\");\n      }\n      if (version !== void 0) {\n        throw new Error(\"You can either use the .legacy or the .version option, not both.\");\n      }\n    }\n    if (version === void 0) {\n      version = legacy ? \"legacy\" : \"2018-09\";\n    } else if (version !== \"2023-05\" && version !== \"2023-01\" && version !== \"2022-03\" && version !== \"2021-12\" && version !== \"2018-09\" && version !== \"legacy\") {\n      throw new Error(\"Unsupported decorators version: \" + version);\n    }\n    var {\n      decoratorsBeforeExport\n    } = options;\n    if (decoratorsBeforeExport === void 0) {\n      if (version === \"2021-12\" || version === \"2022-03\") {\n        decoratorsBeforeExport = false;\n      } else if (version === \"2018-09\") {\n        throw new Error(\"The decorators plugin, when .version is '2018-09' or not specified, requires a 'decoratorsBeforeExport' option, whose value must be a boolean.\");\n      }\n    } else {\n      if (version === \"legacy\" || version === \"2022-03\" || version === \"2023-01\") {\n        throw new Error(`'decoratorsBeforeExport' can't be used with ${version} decorators.`);\n      }\n      if (typeof decoratorsBeforeExport !== \"boolean\") {\n        throw new Error(\"'decoratorsBeforeExport' must be a boolean.\");\n      }\n    }\n  }\n  return {\n    name: \"syntax-decorators\",\n    manipulateOptions({\n      generatorOpts\n    }, parserOpts) {\n      if (version === \"legacy\") {\n        parserOpts.plugins.push(\"decorators-legacy\");\n      } else {\n        if (version === \"2023-01\" || version === \"2023-05\") {\n          parserOpts.plugins.push([\"decorators\", {\n            allowCallParenthesized: false\n          }], \"decoratorAutoAccessors\");\n        } else if (version === \"2022-03\") {\n          parserOpts.plugins.push([\"decorators\", {\n            decoratorsBeforeExport: false,\n            allowCallParenthesized: false\n          }], \"decoratorAutoAccessors\");\n        } else if (version === \"2021-12\") {\n          parserOpts.plugins.push([\"decorators\", {\n            decoratorsBeforeExport\n          }], \"decoratorAutoAccessors\");\n          generatorOpts.decoratorsBeforeExport = decoratorsBeforeExport;\n        } else if (version === \"2018-09\") {\n          parserOpts.plugins.push([\"decorators\", {\n            decoratorsBeforeExport\n          }]);\n          generatorOpts.decoratorsBeforeExport = decoratorsBeforeExport;\n        }\n      }\n    }\n  };\n});\nfunction makeVisitor(babel) {\n  const t = babel.types;\n  return {\n    Program(path, state) {\n      state.currentClassBodies = [];\n      state.currentObjectExpressions = [];\n      state.optsWithDefaults = {\n        runtime: \"globals\",\n        runEarly: false,\n        ...state.opts\n      };\n      state.util = new ImportUtil_1(babel, path);\n      state.runtime = (i, fnName) => {\n        const { runtime } = state.optsWithDefaults;\n        if (runtime === \"globals\") {\n          return t.memberExpression(\n            t.identifier(globalId),\n            t.identifier(fnName)\n          );\n        } else {\n          return i.import(runtime.import, fnName);\n        }\n      };\n    },\n    ClassBody: {\n      enter(path, state) {\n        state.currentClassBodies.unshift(path.node);\n      },\n      exit(path, state) {\n        if (state.currentClassBodies[0] === path.node) {\n          state.currentClassBodies.shift();\n        }\n      }\n    },\n    ClassExpression(path, state) {\n      let decorators = path.get(\"decorators\");\n      if (Array.isArray(decorators) && decorators.length > 0) {\n        state.util.replaceWith(path, (i) => {\n          let call = t.callExpression(state.runtime(i, \"c\"), [\n            path.node,\n            t.arrayExpression(\n              decorators.slice().reverse().map((d) => d.node.expression)\n            )\n          ]);\n          for (let decorator of decorators) {\n            decorator.remove();\n          }\n          return call;\n        });\n      }\n    },\n    ClassDeclaration(path, state) {\n      let decorators = path.get(\"decorators\");\n      if (Array.isArray(decorators) && decorators.length > 0) {\n        const buildCall = (i) => {\n          return t.callExpression(state.runtime(i, \"c\"), [\n            t.classExpression(\n              path.node.id,\n              path.node.superClass,\n              path.node.body,\n              []\n              // decorators removed here\n            ),\n            t.arrayExpression(\n              decorators.slice().reverse().map((d) => d.node.expression)\n            )\n          ]);\n        };\n        if (path.parentPath.isExportDefaultDeclaration()) {\n          let id = path.node.id;\n          if (id) {\n            state.util.insertBefore(\n              path.parentPath,\n              (i) => t.variableDeclaration(\"const\", [\n                t.variableDeclarator(id, buildCall(i))\n              ])\n            );\n            path.parentPath.replaceWith(t.exportDefaultDeclaration(id));\n          } else {\n            state.util.replaceWith(\n              path.parentPath,\n              (i) => t.exportDefaultDeclaration(buildCall(i))\n            );\n          }\n        } else if (path.parentPath.isExportNamedDeclaration()) {\n          let id = path.node.id;\n          if (!id) {\n            throw new Error(\n              `bug: expected a class name is required in this context`\n            );\n          }\n          state.util.insertBefore(\n            path.parentPath,\n            (i) => t.variableDeclaration(\"const\", [\n              t.variableDeclarator(id, buildCall(i))\n            ])\n          );\n          path.parentPath.replaceWith(\n            t.exportNamedDeclaration(null, [t.exportSpecifier(id, id)])\n          );\n        } else {\n          let id = path.node.id;\n          if (!id) {\n            throw new Error(\n              `bug: expected a class name is required in this context`\n            );\n          }\n          state.util.replaceWith(\n            path,\n            (i) => t.variableDeclaration(\"const\", [\n              t.variableDeclarator(id, buildCall(i))\n            ])\n          );\n        }\n      }\n    },\n    ClassProperty(path, state) {\n      let decorators = path.get(\"decorators\");\n      if (Array.isArray(decorators) && decorators.length > 0) {\n        let prototype;\n        if (path.node.static) {\n          prototype = t.thisExpression();\n        } else {\n          prototype = t.memberExpression(\n            t.thisExpression(),\n            t.identifier(\"prototype\")\n          );\n        }\n        let args = [\n          prototype,\n          valueForFieldKey(t, path.node.key),\n          t.arrayExpression(\n            decorators.slice().reverse().map((d) => d.node.expression)\n          )\n        ];\n        if (path.node.value) {\n          args.push(\n            t.functionExpression(\n              null,\n              [],\n              t.blockStatement([t.returnStatement(path.node.value)])\n            )\n          );\n        }\n        state.util.insertBefore(\n          path,\n          (i) => t.staticBlock([\n            t.expressionStatement(\n              t.callExpression(state.runtime(i, \"g\"), args)\n            )\n          ])\n        );\n        state.util.insertBefore(\n          path,\n          (i) => t.classPrivateProperty(\n            t.privateName(\n              t.identifier(\n                unusedPrivateNameLike(state, propName(path.node.key))\n              )\n            ),\n            t.sequenceExpression([\n              t.callExpression(state.runtime(i, \"i\"), [\n                t.thisExpression(),\n                valueForFieldKey(t, path.node.key)\n              ]),\n              t.identifier(\"void 0\")\n            ])\n          )\n        );\n        path.remove();\n      }\n    },\n    ClassMethod(path, state) {\n      let decorators = path.get(\"decorators\");\n      if (Array.isArray(decorators) && decorators.length > 0) {\n        let prototype;\n        if (path.node.static) {\n          prototype = t.thisExpression();\n        } else {\n          prototype = t.memberExpression(\n            t.thisExpression(),\n            t.identifier(\"prototype\")\n          );\n        }\n        state.util.insertAfter(\n          path,\n          (i) => t.staticBlock([\n            t.expressionStatement(\n              t.callExpression(state.runtime(i, \"n\"), [\n                prototype,\n                valueForFieldKey(t, path.node.key),\n                t.arrayExpression(\n                  decorators.slice().reverse().map((d) => d.node.expression)\n                )\n              ])\n            )\n          ])\n        );\n        for (let decorator of decorators) {\n          decorator.remove();\n        }\n      }\n    },\n    ObjectExpression: {\n      enter(path, state) {\n        state.currentObjectExpressions.unshift({\n          node: path.node,\n          decorated: []\n        });\n      },\n      exit(path, state) {\n        var _a;\n        if (((_a = state.currentObjectExpressions[0]) == null ? void 0 : _a.node) !== path.node) {\n          return;\n        }\n        let { decorated } = state.currentObjectExpressions.shift();\n        if (decorated.length > 0) {\n          state.util.replaceWith(\n            path,\n            (i) => t.callExpression(state.runtime(i, \"p\"), [\n              path.node,\n              t.arrayExpression(\n                decorated.map(\n                  ([type, prop, decorators]) => t.arrayExpression([\n                    t.stringLiteral(type),\n                    prop,\n                    t.arrayExpression(decorators)\n                  ])\n                )\n              )\n            ])\n          );\n        }\n      }\n    },\n    ObjectProperty(path, state) {\n      let decorators = path.get(\"decorators\");\n      if (Array.isArray(decorators) && decorators.length > 0) {\n        if (state.currentObjectExpressions.length === 0) {\n          throw new Error(\n            `bug in decorator-transforms: didn't expect to see ObjectProperty outside ObjectExpression`\n          );\n        }\n        let prop = path.node.key;\n        if (prop.type === \"PrivateName\") {\n          throw new Error(`cannot decorate private field`);\n        }\n        state.currentObjectExpressions[0].decorated.push([\n          \"field\",\n          valueForFieldKey(t, prop),\n          decorators.slice().reverse().map((d) => d.node.expression)\n        ]);\n        for (let decorator of decorators) {\n          decorator.remove();\n        }\n      }\n    },\n    ObjectMethod(path, state) {\n      let decorators = path.get(\"decorators\");\n      if (Array.isArray(decorators) && decorators.length > 0) {\n        if (state.currentObjectExpressions.length === 0) {\n          throw new Error(\n            `bug in decorator-transforms: didn't expect to see ObjectMethod outside ObjectExpression`\n          );\n        }\n        let prop = path.node.key;\n        state.currentObjectExpressions[0].decorated.push([\n          \"method\",\n          valueForFieldKey(t, prop),\n          decorators.slice().reverse().map((d) => d.node.expression)\n        ]);\n        for (let decorator of decorators) {\n          decorator.remove();\n        }\n      }\n    }\n  };\n}\nfunction legacyDecoratorCompat(babel) {\n  let visitor = makeVisitor(babel);\n  return {\n    inherits: (api, _options, dirname) => default_1(api, { legacy: true }, dirname),\n    pre(file) {\n      if (this.opts.runEarly) {\n        babel.traverse(file.ast, makeVisitor(babel), file.scope, this);\n        visitor = void 0;\n      }\n    },\n    get visitor() {\n      return visitor ?? {};\n    }\n  };\n}\nfunction unusedPrivateNameLike(state, name2) {\n  let classBody = state.currentClassBodies[0];\n  if (!classBody) {\n    throw new Error(\n      `bug: no current class body around our class field decorator`\n    );\n  }\n  let usedNames = /* @__PURE__ */ new Set();\n  for (let element of classBody.body) {\n    if ((element.type === \"ClassPrivateProperty\" || element.type === \"ClassPrivateMethod\" || element.type === \"ClassAccessorProperty\") && element.key.type === \"PrivateName\") {\n      usedNames.add(element.key.id.name);\n    }\n  }\n  let candidate = name2;\n  while (usedNames.has(candidate)) {\n    candidate = candidate + \"_\";\n  }\n  return candidate;\n}\nfunction propName(expr) {\n  if (expr.type === \"Identifier\") {\n    return expr.name;\n  }\n  if (expr.type === \"BigIntLiteral\" || expr.type === \"NumericLiteral\") {\n    return `_${expr.value}`;\n  }\n  if (expr.type === \"StringLiteral\") {\n    return \"_\" + expr.value.replace(/[^a-zA-Z]/g, \"\");\n  }\n  return \"_\";\n}\nfunction valueForFieldKey(t, expr) {\n  if (expr.type === \"Identifier\") {\n    return t.stringLiteral(expr.name);\n  }\n  return expr;\n}\nexport {\n  legacyDecoratorCompat as default\n};\n//# sourceMappingURL=index.js.map\n","const globalId = `dt7948`;\nexport {\n  globalId as g\n};\n//# sourceMappingURL=global-id-BrhFC90G.js.map\n"],"names":["Object","defineProperty","src","value","ImportUtil_1","ImportUtil","desiredName","nameHint","exportedName","defaultNameHint2","cleaned","replace","_m","letter","toUpperCase","defaultNameHint","target","isIdentifier","node","name","scope","generateUidIdentifierBasedOnNode","matchSpecifier","spec","isImportDefaultSpecifier","isImportNamespaceSpecifier","isImportSpecifier","imported","type","matchModule","path","moduleSpecifier","isImportDeclaration","get","constructor","babel","program","this","t","types","removeImport","topLevelPath","importSpecifierPath","find","specifierPath","specifiers","length","remove","removeAllImports","import","unreferencedImport","preferredName","_a","isNamespaceImport","isNamedImport","declaration","findImportFrom","hasNamespaceSpecifier","s","specifier","getBinding","local","kind","identifier","addSpecifier","declaration2","insertAfterExistingImports","importDeclaration","stringLiteral","importForSideEffect","replaceWith","fn","mutate","i","insertAfter","insertBefore","symbols","Map","updateReference","hit","newIdentifier","binding","Error","reference","result","set","traverse","ReferencedIdentifier","added","name2","candidate","counter","hasBinding","unusedNameLike","buildSpecifier","unshift","push","registerBinding","localName","importDefaultSpecifier","importNamespaceSpecifier","importSpecifier","source","importKind","statement","lastIndex","index","body","entries","splice"],"mappings":"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","x_google_ignoreList":[0,1]}